var bton = function (t) {
    "use strict";
    const n = new TextEncoder,
        e = [{name: "base58", charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}, {
            name: "base64",
            charset: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        }, {name: "base64url", charset: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];

    function r(t) {
        for (const n of e) if (n.name === t) return n.charset;
        throw TypeError("Charset does not exist: " + t)
    }

    const i = {
            encode: function (t, e, i = !1) {
                "string" == typeof t && (t = n.encode(t));
                const o = r(e), s = o.length, a = [];
                let c, u, f, h = "", l = 0;
                for (c = 0; c < t.length; c++) for (l = 0, u = t[c], h += u > 0 || (h.length ^ c) > 0 ? "" : "1"; l in a || u > 0;) f = a[l], f = f > 0 ? 256 * f + u : u, u = f / s | 0, a[l] = f % s, l++;
                for (; l-- > 0;) h += o[a[l]];
                return i && h.length % 4 > 0 ? h + "=".repeat(4 - h.length % 4) : h
            }, decode: function (t, n) {
                const e = r(n), i = e.length, o = [], s = [];
                t = t.replace("=", "");
                let a, c, u, f = 0;
                for (a = 0; a < t.length; a++) {
                    if (f = 0, c = e.indexOf(t[a]), c < 0) throw new Error(`Character range out of bounds: ${c}`);
                    for (c > 0 || (s.length ^ a) > 0 || s.push(0); f in o || c > 0;) u = o[f], u = u > 0 ? u * i + c : c, c = u >> 8, o[f] = u % 256, f++
                }
                for (; f-- > 0;) s.push(o[f]);
                return new Uint8Array(s)
            }
        }, o = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", s = [996825010, 642813549, 513874426, 1027748829, 705979059],
        a = {BECH32: "bech32", BECH32M: "bech32m"};

    function c(t) {
        switch (t) {
            case a.BECH32:
                return 1;
            case a.BECH32M:
                return 734539939;
            default:
                throw new Error(`Unrecognized encoding: ${t}`)
        }
    }

    function u(t) {
        let n = 1;
        for (let e = 0; e < t.length; ++e) {
            const r = n >> 25;
            n = (33554431 & n) << 5 ^ t[e];
            for (let t = 0; t < 5; ++t) (r >> t & 1) > 0 && (n ^= s[t])
        }
        return n
    }

    function f(t) {
        const n = [];
        let e;
        for (e = 0; e < t.length; ++e) n.push(t.charCodeAt(e) >> 5);
        for (n.push(0), e = 0; e < t.length; ++e) n.push(31 & t.charCodeAt(e));
        return n
    }

    function h(t, n, e, r = !0) {
        const i = [];
        let o = 0, s = 0;
        const a = (1 << e) - 1, c = (1 << n + e - 1) - 1;
        for (const r of t) {
            if (r < 0 || r >> n > 0) return [];
            for (o = (o << n | r) & c, s += n; s >= e;) s -= e, i.push(o >> s & a)
        }
        if (r) s > 0 && i.push(o << e - s & a); else if (s >= n || (o << e - s & a) > 0) return [];
        return i
    }

    function l(t, n, e) {
        const r = n.concat(function (t, n, e) {
            const r = u(f(t).concat(n).concat([0, 0, 0, 0, 0, 0])) ^ c(e), i = [];
            for (let t = 0; t < 6; ++t) i.push(r >> 5 * (5 - t) & 31);
            return i
        }(t, n, e));
        let i = t + "1";
        for (let t = 0; t < r.length; ++t) i += o.charAt(r[t]);
        return i
    }

    function d(t, n) {
        const e = n > 0 ? "bech32m" : "bech32";
        if (!function (t) {
            let n, e, r = !1, i = !1;
            for (n = 0; n < t.length; ++n) {
                if (e = t.charCodeAt(n), e < 33 || e > 126) return !1;
                e >= 97 && e <= 122 && (r = !0), e >= 65 && e <= 90 && (i = !0)
            }
            return !(r && i)
        }(t)) return {hrp: null, data: [255]};
        if (!function (t) {
            const n = t.lastIndexOf("1");
            return !(n < 1 || n + 7 > t.length || t.length > 90)
        }(t = t.toLowerCase())) return {hrp: null, data: [255]};
        const r = [], i = t.lastIndexOf("1"), s = t.substring(0, i);
        for (let n = i + 1; n < t.length; ++n) {
            const e = o.indexOf(t.charAt(n));
            if (-1 === e) return {hrp: null, data: [255]};
            r.push(e)
        }
        return function (t, n, e) {
            return u(f(t).concat(n)) === c(e)
        }(s, r, e) ? {hrp: s, data: r.slice(0, r.length - 6)} : {hrp: null, data: [255]}
    }

    function w(t, n = 0) {
        const e = t.split("1", 1)[0], {hrp: r, data: i} = d(t, n), o = h(i.slice(1), 5, 8, !1), s = o.length;
        switch (!0) {
            case e !== r:
                throw new Error("Returned hrp string is invalid.");
            case null === o || s < 2 || s > 40:
                throw new Error("Decoded string is invalid or out of spec.");
            case i[0] > 16:
                throw new Error("Returned version bit is out of range.");
            case 0 === i[0] && 20 !== s && 32 !== s:
                throw new Error("Decoded string does not match version 0 spec.");
            case 0 === i[0] && 0 !== n:
            case 0 !== i[0] && 1 !== n:
                throw new Error("Decoded version bit does not match.");
            default:
                return Uint8Array.from(o)
        }
    }

    const y = {
        encode: function (t, n = "bch", e = 0) {
            const r = l(n, [e, ...h([...t], 8, 5)], e > 0 ? "bech32m" : "bech32");
            return w(r, e), r
        }, decode: w
    }, g = new TextEncoder, p = new TextDecoder;

    function m(t) {
        return g.encode(t)
    }

    function b(t) {
        const n = [];
        let e, r = 0;
        if (t.length % 2 > 0) throw new Error(`Invalid hex string length: ${t.length}`);
        for (e = 0; e < t.length; e += 2) n[r] = parseInt(t.slice(e, e + 2), 16), r += 1;
        return Uint8Array.from(n)
    }

    function A(t) {
        if (0 === t) return Uint8Array.of(0);
        const n = [];
        for (; t > 0;) {
            const e = 255 & t;
            n.push(e), t = (t - e) / 256
        }
        return Uint8Array.from(n)
    }

    function x(t) {
        if (0n === t) return Uint8Array.of(0);
        const n = [];
        for (; t > 0n;) {
            const e = 0xffn & t;
            n.push(Number(e)), t = (t - e) / 256n
        }
        return Uint8Array.from(n)
    }

    function E(t) {
        return p.decode(t)
    }

    function v(t) {
        let n, e = 0;
        for (n = t.length - 1; n >= 0; n--) e = 256 * e + t[n];
        return Number(e)
    }

    function S(t) {
        let n, e = 0n;
        for (n = t.length - 1; n >= 0; n--) e = 256n * e + BigInt(t[n]);
        return BigInt(e)
    }

    async function P(t) {
        return crypto.subtle.digest("SHA-256", t).then((t => new Uint8Array(t)))
    }

    async function O(t) {
        return P(await P(t))
    }

    const {crypto: U} = globalThis;
    let _ = class extends Uint8Array {
        static {
            this.num = (t, n, e = "le") => {
                const r = new _(A(t), n);
                return "le" === e ? r.reverse() : r
            }
        }
        static {
            this.big = (t, n, e = "le") => {
                const r = new _(x(t), n);
                return "le" === e ? r.reverse() : r
            }
        }

        static async b58check(t) {
            const n = i.decode(t, "base58");
            return new _(await async function (t) {
                const n = t.slice(0, -4), e = t.slice(-4);
                if ((await O(n)).slice(0, 4).toString() !== e.toString()) throw new Error("Invalid checksum!");
                return n
            }(n))
        }

        static {
            this.any = (t, n) => new _(function (t) {
                if (t instanceof ArrayBuffer) return new Uint8Array(t);
                if (t instanceof Uint8Array) return t;
                const n = typeof t;
                switch (n) {
                    case"bigint":
                        return x(t);
                    case"boolean":
                        return Uint8Array.of(t);
                    case"number":
                        return A(t);
                    case"string":
                        return null !== t.match(/^(02|03)*[0-9a-fA-F]{64}$/) ? b(t) : g.encode(t);
                    default:
                        throw TypeError("Unsupported format:" + n)
                }
            }(t), n)
        }
        static {
            this.raw = (t, n) => new _(t, n)
        }
        static {
            this.str = (t, n) => new _(m(t), n)
        }
        static {
            this.hex = (t, n) => new _(b(t), n)
        }
        static {
            this.json = t => new _(m(JSON.stringify(t)))
        }
        static {
            this.base64 = t => new _(i.decode(t, "base64"))
        }
        static {
            this.b64url = t => new _(i.decode(t, "base64url"))
        }
        static {
            this.bech32 = (t, n = 0) => new _(y.decode(t, n))
        }

        constructor(t, n) {
            if (void 0 !== n) {
                const e = new Uint8Array(n).fill(0);
                e.set(new Uint8Array(t)), t = e.buffer
            }
            return super(t), this
        }

        get num() {
            return this.toNum()
        }

        get big() {
            return this.toBig()
        }

        get arr() {
            return this.toArr()
        }

        get str() {
            return this.toStr()
        }

        get hex() {
            return this.toHex()
        }

        get raw() {
            return new Uint8Array(this)
        }

        get base64() {
            return this.toBase64()
        }

        get b64url() {
            return this.toB64url()
        }

        get digest() {
            return this.toDigest()
        }

        get id() {
            return this.toDigest().then((t => new _(t).hex))
        }

        toNum(t = "le") {
            return v("le" === t ? this.reverse() : this)
        }

        toBig(t = "le") {
            return S("le" === t ? this.reverse() : this)
        }

        async toDigest(t = "SHA-256") {
            return U.subtle.digest(t, this.raw).then((t => new Uint8Array(t)))
        }

        async tob58check() {
            return i.encode(await async function (t) {
                const n = await O(t);
                return Uint8Array.of(...t, ...n.slice(0, 4))
            }(this), "base58")
        }

        toArr() {
            return Array.from(this)
        }

        toStr() {
            return E(this)
        }

        toHex() {
            return function (t) {
                const n = [];
                let e;
                for (e = 0; e < t.length; e++) n.push(t[e].toString(16).padStart(2, "0"));
                return n.join("")
            }(this)
        }

        toJson() {
            return JSON.parse(E(this))
        }

        toBytes() {
            return new Uint8Array(this)
        }

        toB64url() {
            return i.encode(this, "base64url")
        }

        toBase64(t) {
            return i.encode(this, "base64", t)
        }

        toBech32(t, n = 0) {
            return y.encode(this, t, n)
        }

        prepend(t) {
            return _.of(...t, ...this)
        }

        append(t) {
            return _.of(...this, ...t)
        }

        slice(t, n) {
            return new _(new Uint8Array(this).slice(t, n))
        }

        reverse() {
            return new _(new Uint8Array(this).reverse())
        }

        write(t, n) {
            this.set(t, n)
        }

        prefixSize2(t) {
            return _.of(..._.readSize(this.length, t), ...this)
        }

        // Rarity Garden Hack
        prefixSize(t) {

            const sized = _.readSize(this.length, t);
            const thised = this;

            var uint8 = new Uint8Array(sized.length + thised.length);
            uint8.set(sized);
            uint8.set(thised, sized.length);

            return new _(uint8)
        }

        static from(t) {
            return new _(Uint8Array.from(t))
        }

        static of2(...t) {
            return new _(Uint8Array.of(...t))
        }

        // Rarity Garden Hack
        static of(...t) {

            const uint8 = new Uint8Array(t.length);

            for(let i = 0; i < uint8.length; i++)
            {
                uint8[i] = t[i];
            }

            return new _(uint8)
        }

        static join(t) {
            let n, e = 0;
            const r = t.reduce(((t, n) => t + n.length), 0), i = new Uint8Array(r);
            for (const r of t) for (n = 0; n < r.length; e++, n++) i[e] = r[n];
            return new _(i, r)
        }

        static readSize(t, n) {
            if (t < 253) return _.num(t, 1);
            if (t < 65536) return _.of(253, ..._.num(t, 2, n));
            if (t < 4294967296) return _.of(254, ..._.num(t, 4, n));
            if (t < 0x10000000000000000) return _.of(255, ..._.num(t, 8, n));
            throw new Error(`Value is too large: ${t}`)
        }

        static random(t = 32) {
            return new _(U.getRandomValues(new Uint8Array(t)))
        }

        static {
            this.encode = m
        }
        static {
            this.decode = E
        }

        static normalize(t, n) {
            if (t instanceof Uint8Array) return t;
            if ("string" == typeof t) return _.hex(t, n).raw;
            if ("number" == typeof t) return _.num(t, n).raw;
            if ("bigint" == typeof t) return _.big(t, n).raw;
            throw TypeError("Unrecognized format: " + typeof t)
        }

        static serialize(t) {
            if ("string" == typeof t) return _.str(t).raw;
            if ("object" == typeof t) {
                if (t instanceof Uint8Array) return t;
                try {
                    return _.json(t).raw
                } catch {
                    throw TypeError("Object is not serializable.")
                }
            }
            throw TypeError("Unrecognized format: " + typeof t)
        }

        static revitalize(t) {
            if (t instanceof Uint8Array && (t = E(t)), "string" == typeof t) try {
                return JSON.parse(t)
            } catch {
                return t
            }
            return t
        }
    };

    class B {
        constructor(t) {
            this.data = new Uint8Array(t), this.size = this.data.length
        }

        peek(t) {
            if (t > this.size) throw new Error(`Size greater than stream: ${t} > ${this.size}`);
            return new _(this.data.slice(0, t).buffer)
        }

        read(t) {
            t = t ?? this.readSize();
            const n = this.peek(t);
            return this.data = this.data.slice(t), this.size = this.data.length, n
        }

        readSize() {
            const t = this.read(1).toNum();
            switch (!0) {
                case t >= 0 && t < 253:
                    return t;
                case 253 === t:
                    return this.read(2).toNum();
                case 254 === t:
                    return this.read(4).toNum();
                case 255 === t:
                    return this.read(8).toNum();
                default:
                    throw new Error(`Varint is out of range: ${t}`)
            }
        }
    }

    const I = {
        OP_0: 0,
        OP_PUSHDATA1: 76,
        OP_PUSHDATA2: 77,
        OP_PUSHDATA4: 78,
        OP_1NEGATE: 79,
        OP_1: 81,
        OP_2: 82,
        OP_3: 83,
        OP_4: 84,
        OP_5: 85,
        OP_6: 86,
        OP_7: 87,
        OP_8: 88,
        OP_9: 89,
        OP_10: 90,
        OP_11: 91,
        OP_12: 92,
        OP_13: 93,
        OP_14: 94,
        OP_15: 95,
        OP_16: 96,
        OP_NOP: 97,
        OP_IF: 99,
        OP_NOTIF: 100,
        OP_ELSE: 103,
        OP_ENDIF: 104,
        OP_VERIFY: 105,
        OP_RETURN: 106,
        OP_TOALTSTACK: 107,
        OP_FROMALTSTACK: 108,
        OP_2DROP: 109,
        OP_2DUP: 110,
        OP_3DUP: 111,
        OP_2OVER: 112,
        OP_2ROT: 113,
        OP_2SWAP: 114,
        OP_IFDUP: 115,
        OP_DEPTH: 116,
        OP_DROP: 117,
        OP_DUP: 118,
        OP_NIP: 119,
        OP_OVER: 120,
        OP_PICK: 121,
        OP_ROLL: 122,
        OP_ROT: 123,
        OP_SWAP: 124,
        OP_TUCK: 125,
        OP_SIZE: 130,
        OP_EQUAL: 135,
        OP_EQUALVERIFY: 136,
        OP_1ADD: 139,
        OP_1SUB: 140,
        OP_NEGATE: 143,
        OP_ABS: 144,
        OP_NOT: 145,
        OP_0NOTEQUAL: 146,
        OP_ADD: 147,
        OP_SUB: 148,
        OP_BOOLAND: 154,
        OP_BOOLOR: 155,
        OP_NUMEQUAL: 156,
        OP_NUMEQUALVERIFY: 157,
        OP_NUMNOTEQUAL: 158,
        OP_LESSTHAN: 159,
        OP_GREATERTHAN: 160,
        OP_LESSTHANOREQUAL: 161,
        OP_GREATERTHANOREQUAL: 162,
        OP_MIN: 163,
        OP_MAX: 164,
        OP_WITHIN: 165,
        OP_RIPEMD160: 166,
        OP_SHA1: 167,
        OP_SHA256: 168,
        OP_HASH160: 169,
        OP_HASH256: 170,
        OP_CODESEPARATOR: 171,
        OP_CHECKSIG: 172,
        OP_CHECKSIGVERIFY: 173,
        OP_CHECKMULTISIG: 174,
        OP_CHECKMULTISIGVERIFY: 175,
        OP_NOP1: 176,
        OP_CHECKLOCKTIMEVERIFY: 177,
        OP_CHECKSEQUENCEVERIFY: 178,
        OP_NOP4: 179,
        OP_NOP5: 180,
        OP_NOP6: 181,
        OP_NOP7: 182,
        OP_NOP8: 183,
        OP_NOP9: 184,
        OP_NOP10: 185
    };

    function H(t) {
        for (const [n, e] of Object.entries(I)) if (e === t) return n;
        throw new Error("OPCODE not found:" + String(t))
    }

    const z = 520;

    function N(t = [], n = !0) {
        let e = _.num(0);
        return Array.isArray(t) && (e = _.raw(T(t))), "string" == typeof t && (e = _.hex(t)), t instanceof Uint8Array && (e = _.raw(t)), n && (e = e.prefixSize("be")), e.raw
    }

    function T(t) {
        const n = [];
        for (const e of t) n.push(R(e));
        return n.length > 0 ? _.join(n) : new Uint8Array
    }

    function R(t) {
        let n = new Uint8Array;
        if ("string" == typeof t) {
            if (t.startsWith("OP_")) return _.num(function (t) {
                for (const [n, e] of Object.entries(I)) if (n === t) return Number(e);
                throw new Error("OPCODE not found:" + t)
            }(t), 1);
            t.startsWith("STR_") && (n = _.str(t.slice(3))), n = _.hex(t)
        }
        if ("number" == typeof t && (n = _.num(t)), t instanceof Uint8Array && (n = t), n.length > z) {
            const t = function (t) {
                const n = [], e = new B(t);
                for (; e.size > z;) n.push(e.read(z));
                return n.push(e.read(e.size)), n
            }(n);
            return T(t)
        }
        return _.of(...function (t) {
            const n = _.num(76, 1), e = _.num(77, 1);
            switch (!0) {
                case t <= 75:
                    return _.num(t);
                case t > 75 && t < 256:
                    return _.join([n, _.num(t, 1)]);
                case t >= 256 && t <= z:
                    return _.join([e, _.num(t, 2, "be")]);
                default:
                    throw new Error("Invalid word size:" + t.toString())
            }
        }(n.length), ...n)
    }

    function k(t) {
        return _.num(t, 4).reverse()
    }

    function C(t) {
        return _.hex(t, 32).reverse()
    }

    function D(t) {
        return _.num(t, 4).reverse()
    }

    function K(t = 4294967295) {
        return ("string" == typeof t ? _.hex(t, 4) : _.num(t, 4)).reverse()
    }

    function j(t) {
        return "number" == typeof t && (t = BigInt(t)), _.big(t, 8).reverse()
    }

    function $(t) {
        const n = [];
        if (Array.isArray(t)) {
            n.push(_.readSize(t.length));
            for (const e of t) n.push(N(e));
            return _.join(n)
        }
        return _.normalize(t)
    }

    function V(t) {
        return _.num(t, 4).reverse()
    }

    function L(t) {
        "string" == typeof t && (t = _.hex(t).raw);
        const n = new B(t), e = function (t) {
            return t.read(4).reverse().toNum()
        }(n), r = function (t) {
            const [n, e] = [...t.peek(2)];
            if (0 === n) {
                if (t.read(2), 1 === e) return !0;
                throw new Error(`Invalid witness flag: ${e}`)
            }
            return !1
        }(n), i = function (t) {
            const n = [], e = t.readSize();
            for (let r = 0; r < e; r++) n.push(q(t));
            return n
        }(n), o = function (t) {
            const n = [], e = t.readSize();
            for (let r = 0; r < e; r++) n.push(F(t));
            return n
        }(n);
        if (r) for (const t of i) t.witness = M(n);
        const s = function (t) {
            return t.read(4).reverse().toNum()
        }(n);
        return {version: e, input: i, output: o, locktime: s}
    }

    function q(t) {
        return {
            txid: t.read(32).reverse().toHex(),
            vout: t.read(4).reverse().toNum(),
            scriptSig: Y(t, !0),
            sequence: t.read(4).reverse().toHex()
        }
    }

    function F(t) {
        return {value: t.read(8).reverse().big, scriptPubKey: Y(t, !0)}
    }

    function M(t) {
        const n = [], e = t.readSize();
        for (let r = 0; r < e; r++) {
            const e = Y(t, !0);
            n.push(e)
        }
        return n
    }

    function Y(t, n) {
        const e = !0 === n ? t.readSize() : t.size;
        return e > 0 ? t.read(e).toHex() : _.num(0).toHex()
    }

    function Z(t) {
        if (void 0 === t) throw new Error("Script data is undefined!");
        if (Array.isArray(t)) throw new Error("Script data is an array!");
        return _.normalize(t)
    }

    function W(t) {
        switch (!0) {
            case 0 === t:
                return "opcode";
            case t >= 1 && t <= 75:
                return "varint";
            case 76 === t:
                return "pushdata1";
            case 77 === t:
                return "pushdata2";
            case 78 === t:
                return "pushdata4";
            case t <= 185:
                return "opcode";
            default:
                throw new Error(`Invalid word range: ${t}`)
        }
    }

    function G(t) {
        switch (!0) {
            case"number" != typeof t:
                return !1;
            case 0 === t:
                return !0;
            case[126, 127, 128, 129, 131, 132, 133, 134, 141, 142, 149, 150, 151, 152, 153].includes(t):
                return !1;
            case 75 < t && t < 186:
                return !0;
            default:
                return !1
        }
    }

    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
    const {crypto: X} = globalThis, J = BigInt(0), Q = BigInt(1), tt = BigInt(2), nt = BigInt(3), et = BigInt(8),
        rt = Object.freeze({
            a: J,
            b: BigInt(7),
            P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
            n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
            h: Q,
            Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
            Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
        }), it = (t, n) => (t + n / tt) / n, ot = {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar(t) {
                const {n: n} = rt, e = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    r = -Q * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = e,
                    s = BigInt("0x100000000000000000000000000000000"), a = it(o * t, n), c = it(-r * t, n);
                let u = Tt(t - a * e - c * i, n), f = Tt(-a * r - c * o, n);
                const h = u > s, l = f > s;
                if (h && (u = n - u), l && (f = n - f), u > s || f > s) throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
                return {k1neg: h, k1: u, k2neg: l, k2: f}
            }
        }, st = 32, at = 32, ct = 32, ut = st + 1, ft = 2 * st + 1;

    function ht(t) {
        const {a: n, b: e} = rt, r = Tt(t * t), i = Tt(r * t);
        return Tt(i + n * t + e)
    }

    const lt = rt.a === J;

    class dt extends Error {
        constructor(t) {
            super(t)
        }
    }

    function wt(t) {
        if (!(t instanceof yt)) throw new TypeError("JacobianPoint expected")
    }

    class yt {
        constructor(t, n, e) {
            this.x = t, this.y = n, this.z = e
        }

        static get BASE() {
            return new yt(rt.Gx, rt.Gy, Q)
        }

        static get ZERO() {
            return new yt(J, Q, J)
        }

        static fromAffine(t) {
            if (!(t instanceof mt)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(mt.ZERO) ? yt.ZERO : new yt(t.x, t.y, Q)
        }

        static toAffineBatch(t) {
            const n = function (t, n = rt.P) {
                const e = new Array(t.length),
                    r = kt(t.reduce(((t, r, i) => r === J ? t : (e[i] = t, Tt(t * r, n))), Q), n);
                return t.reduceRight(((t, r, i) => r === J ? t : (e[i] = Tt(t * e[i], n), Tt(t * r, n))), r), e
            }(t.map((t => t.z)));
            return t.map(((t, e) => t.toAffine(n[e])))
        }

        static normalizeZ(t) {
            return yt.toAffineBatch(t).map(yt.fromAffine)
        }

        equals(t) {
            wt(t);
            const {x: n, y: e, z: r} = this, {x: i, y: o, z: s} = t, a = Tt(r * r), c = Tt(s * s), u = Tt(n * c),
                f = Tt(i * a), h = Tt(Tt(e * s) * c), l = Tt(Tt(o * r) * a);
            return u === f && h === l
        }

        negate() {
            return new yt(this.x, Tt(-this.y), this.z)
        }

        double() {
            const {x: t, y: n, z: e} = this, r = Tt(t * t), i = Tt(n * n), o = Tt(i * i), s = t + i,
                a = Tt(tt * (Tt(s * s) - r - o)), c = Tt(nt * r), u = Tt(c * c), f = Tt(u - tt * a),
                h = Tt(c * (a - f) - et * o), l = Tt(tt * n * e);
            return new yt(f, h, l)
        }

        add(t) {
            wt(t);
            const {x: n, y: e, z: r} = this, {x: i, y: o, z: s} = t;
            if (i === J || o === J) return this;
            if (n === J || e === J) return t;
            const a = Tt(r * r), c = Tt(s * s), u = Tt(n * c), f = Tt(i * a), h = Tt(Tt(e * s) * c),
                l = Tt(Tt(o * r) * a), d = Tt(f - u), w = Tt(l - h);
            if (d === J) return w === J ? this.double() : yt.ZERO;
            const y = Tt(d * d), g = Tt(d * y), p = Tt(u * y), m = Tt(w * w - g - tt * p), b = Tt(w * (p - m) - h * g),
                A = Tt(r * s * d);
            return new yt(m, b, A)
        }

        subtract(t) {
            return this.add(t.negate())
        }

        multiplyUnsafe(t) {
            const n = yt.ZERO;
            if ("bigint" == typeof t && t === J) return n;
            let e = Nt(t);
            if (e === Q) return this;
            if (!lt) {
                let t = n, r = this;
                for (; e > J;) e & Q && (t = t.add(r)), r = r.double(), e >>= Q;
                return t
            }
            let {k1neg: r, k1: i, k2neg: o, k2: s} = ot.splitScalar(e), a = n, c = n, u = this;
            for (; i > J || s > J;) i & Q && (a = a.add(u)), s & Q && (c = c.add(u)), u = u.double(), i >>= Q, s >>= Q;
            return r && (a = a.negate()), o && (c = c.negate()), c = new yt(Tt(c.x * ot.beta), c.y, c.z), a.add(c)
        }

        precomputeWindow(t) {
            const n = lt ? 128 / t + 1 : 256 / t + 1, e = [];
            let r = this, i = r;
            for (let o = 0; o < n; o++) {
                i = r, e.push(i);
                for (let n = 1; n < 2 ** (t - 1); n++) i = i.add(r), e.push(i);
                r = i.double()
            }
            return e
        }

        wNAF(t, n) {
            !n && this.equals(yt.BASE) && (n = mt.BASE);
            const e = n && n._WINDOW_SIZE || 1;
            if (256 % e) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let r = n && pt.get(n);
            r || (r = this.precomputeWindow(e), n && 1 !== e && (r = yt.normalizeZ(r), pt.set(n, r)));
            let i = yt.ZERO, o = yt.BASE;
            const s = 1 + (lt ? 128 / e : 256 / e), a = 2 ** (e - 1), c = BigInt(2 ** e - 1), u = 2 ** e, f = BigInt(e);
            for (let n = 0; n < s; n++) {
                const e = n * a;
                let s = Number(t & c);
                t >>= f, s > a && (s -= u, t += Q);
                const h = e, l = e + Math.abs(s) - 1, d = n % 2 != 0, w = s < 0;
                0 === s ? o = o.add(gt(d, r[h])) : i = i.add(gt(w, r[l]))
            }
            return {p: i, f: o}
        }

        multiply(t, n) {
            let e, r, i = Nt(t);
            if (lt) {
                const {k1neg: t, k1: o, k2neg: s, k2: a} = ot.splitScalar(i);
                let {p: c, f: u} = this.wNAF(o, n), {p: f, f: h} = this.wNAF(a, n);
                c = gt(t, c), f = gt(s, f), f = new yt(Tt(f.x * ot.beta), f.y, f.z), e = c.add(f), r = u.add(h)
            } else {
                const {p: t, f: o} = this.wNAF(i, n);
                e = t, r = o
            }
            return yt.normalizeZ([e, r])[0]
        }

        toAffine(t) {
            const {x: n, y: e, z: r} = this, i = this.equals(yt.ZERO);
            null == t && (t = i ? et : kt(r));
            const o = t, s = Tt(o * o), a = Tt(s * o), c = Tt(n * s), u = Tt(e * a), f = Tt(r * o);
            if (i) return mt.ZERO;
            if (f !== Q) throw new Error("invZ was invalid");
            return new mt(c, u)
        }
    }

    function gt(t, n) {
        const e = n.negate();
        return t ? e : n
    }

    const pt = new WeakMap;
    let mt = class {
        constructor(t, n) {
            this.x = t, this.y = n
        }

        _setWindowSize(t) {
            this._WINDOW_SIZE = t, pt.delete(this)
        }

        static get BASE() {
            return new mt(rt.Gx, rt.Gy)
        }

        static get ZERO() {
            return new mt(J, J)
        }

        hasEvenY() {
            return this.y % tt === J
        }

        static fromCompressedHex(t) {
            const n = 32 === t.length, e = Ht(n ? t : t.subarray(1));
            if (!Vt(e)) throw new Error("Point is not on curve");
            let r = function (t) {
                const {P: n} = rt, e = BigInt(6), r = BigInt(11), i = BigInt(22), o = BigInt(23), s = BigInt(44),
                    a = BigInt(88), c = t * t * t % n, u = c * c * t % n, f = Rt(u, nt) * u % n, h = Rt(f, nt) * u % n,
                    l = Rt(h, tt) * c % n, d = Rt(l, r) * l % n, w = Rt(d, i) * d % n, y = Rt(w, s) * w % n,
                    g = Rt(y, a) * y % n, p = Rt(g, s) * w % n, m = Rt(p, nt) * u % n, b = Rt(m, o) * d % n,
                    A = Rt(b, e) * c % n, x = Rt(A, tt);
                if (x * x % n !== t) throw new Error("Cannot find square root");
                return x
            }(ht(e));
            const i = (r & Q) === Q;
            if (n) i && (r = Tt(-r)); else {
                1 == (1 & t[0]) !== i && (r = Tt(-r))
            }
            const o = new mt(e, r);
            return o.assertValidity(), o
        }

        static fromUncompressedHex(t) {
            const n = Ht(t.subarray(1, st + 1)), e = Ht(t.subarray(st + 1, 2 * st + 1)), r = new mt(n, e);
            return r.assertValidity(), r
        }

        static fromHex(t) {
            const n = zt(t), e = n.length, r = n[0];
            if (e === st) return this.fromCompressedHex(n);
            if (e === ut && (2 === r || 3 === r)) return this.fromCompressedHex(n);
            if (e === ft && 4 === r) return this.fromUncompressedHex(n);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-${ut} compressed bytes or ${ft} uncompressed bytes, not ${e}`)
        }

        static fromPrivateKey(t) {
            return mt.BASE.multiply(qt(t))
        }

        static fromSignature(t, n, e) {
            const {r: r, s: i} = Mt(n);
            if (![0, 1, 2, 3].includes(e)) throw new Error("Cannot recover: invalid recovery bit");
            const o = Ct(zt(t)), {n: s} = rt, a = 2 === e || 3 === e ? r + s : r, c = kt(a, s), u = Tt(-o * c, s),
                f = Tt(i * c, s), h = 1 & e ? "03" : "02", l = mt.fromHex(h + Ot(a)),
                d = mt.BASE.multiplyAndAddUnsafe(l, u, f);
            if (!d) throw new Error("Cannot recover signature: point at infinify");
            return d.assertValidity(), d
        }

        toRawBytes(t = !1) {
            return It(this.toHex(t))
        }

        toHex(t = !1) {
            const n = Ot(this.x);
            if (t) {
                return `${this.hasEvenY() ? "02" : "03"}${n}`
            }
            return `04${n}${Ot(this.y)}`
        }

        toHexX() {
            return this.toHex(!0).slice(2)
        }

        toRawX() {
            return this.toRawBytes(!0).slice(1)
        }

        assertValidity() {
            const t = "Point is not on elliptic curve", {x: n, y: e} = this;
            if (!Vt(n) || !Vt(e)) throw new Error(t);
            const r = Tt(e * e);
            if (Tt(r - ht(n)) !== J) throw new Error(t)
        }

        equals(t) {
            return this.x === t.x && this.y === t.y
        }

        negate() {
            return new mt(this.x, Tt(-this.y))
        }

        double() {
            return yt.fromAffine(this).double().toAffine()
        }

        add(t) {
            return yt.fromAffine(this).add(yt.fromAffine(t)).toAffine()
        }

        subtract(t) {
            return this.add(t.negate())
        }

        multiply(t) {
            return yt.fromAffine(this).multiply(t, this).toAffine()
        }

        multiplyAndAddUnsafe(t, n, e) {
            const r = yt.fromAffine(this),
                i = n === J || n === Q || this !== mt.BASE ? r.multiplyUnsafe(n) : r.multiply(n),
                o = yt.fromAffine(t).multiplyUnsafe(e), s = i.add(o);
            return s.equals(yt.ZERO) ? void 0 : s.toAffine()
        }
    };

    function bt(t) {
        return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t
    }

    function At(t) {
        if (t.length < 2 || 2 !== t[0]) throw new Error(`Invalid signature integer tag: ${St(t)}`);
        const n = t[1], e = t.subarray(2, n + 2);
        if (!n || e.length !== n) throw new Error("Invalid signature integer: wrong length");
        if (0 === e[0] && e[1] <= 127) throw new Error("Invalid signature integer: trailing length");
        return {data: Ht(e), left: t.subarray(n + 2)}
    }

    class xt {
        constructor(t, n) {
            this.r = t, this.s = n, this.assertValidity()
        }

        static fromCompact(t) {
            const n = t instanceof Uint8Array, e = "Signature.fromCompact";
            if ("string" != typeof t && !n) throw new TypeError(`${e}: Expected string or Uint8Array`);
            const r = n ? St(t) : t;
            if (128 !== r.length) throw new Error(`${e}: Expected 64-byte hex`);
            return new xt(Bt(r.slice(0, 64)), Bt(r.slice(64, 128)))
        }

        static fromDER(t) {
            const n = t instanceof Uint8Array;
            if ("string" != typeof t && !n) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            const {r: e, s: r} = function (t) {
                if (t.length < 2 || 48 != t[0]) throw new Error(`Invalid signature tag: ${St(t)}`);
                if (t[1] !== t.length - 2) throw new Error("Invalid signature: incorrect length");
                const {data: n, left: e} = At(t.subarray(2)), {data: r, left: i} = At(e);
                if (i.length) throw new Error(`Invalid signature: left bytes after parsing: ${St(i)}`);
                return {r: n, s: r}
            }(n ? t : It(t));
            return new xt(e, r)
        }

        static fromHex(t) {
            return this.fromDER(t)
        }

        assertValidity() {
            const {r: t, s: n} = this;
            if (!$t(t)) throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!$t(n)) throw new Error("Invalid Signature: s must be 0 < s < n")
        }

        hasHighS() {
            const t = rt.n >> Q;
            return this.s > t
        }

        normalizeS() {
            return this.hasHighS() ? new xt(this.r, Tt(-this.s, rt.n)) : this
        }

        toDERRawBytes() {
            return It(this.toDERHex())
        }

        toDERHex() {
            const t = bt(_t(this.s)), n = bt(_t(this.r)), e = t.length / 2, r = n.length / 2, i = _t(e), o = _t(r);
            return `30${_t(r + e + 4)}02${o}${n}02${i}${t}`
        }

        toRawBytes() {
            return this.toDERRawBytes()
        }

        toHex() {
            return this.toDERHex()
        }

        toCompactRawBytes() {
            return It(this.toCompactHex())
        }

        toCompactHex() {
            return Ot(this.r) + Ot(this.s)
        }
    }

    function Et(...t) {
        if (!t.every((t => t instanceof Uint8Array))) throw new Error("Uint8Array list expected");
        if (1 === t.length) return t[0];
        const n = t.reduce(((t, n) => t + n.length), 0), e = new Uint8Array(n);
        for (let n = 0, r = 0; n < t.length; n++) {
            const i = t[n];
            e.set(i, r), r += i.length
        }
        return e
    }

    const vt = Array.from({length: 256}, ((t, n) => n.toString(16).padStart(2, "0")));

    function St(t) {
        if (!(t instanceof Uint8Array)) throw new Error("Expected Uint8Array");
        let n = "";
        for (let e = 0; e < t.length; e++) n += vt[t[e]];
        return n
    }

    const Pt = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");

    function Ot(t) {
        if ("bigint" != typeof t) throw new Error("Expected bigint");
        if (!(J <= t && t < Pt)) throw new Error("Expected number 0 <= n < 2^256");
        return t.toString(16).padStart(64, "0")
    }

    function Ut(t) {
        const n = It(Ot(t));
        if (32 !== n.length) throw new Error("Error: expected 32 bytes");
        return n
    }

    function _t(t) {
        const n = t.toString(16);
        return 1 & n.length ? `0${n}` : n
    }

    function Bt(t) {
        if ("string" != typeof t) throw new TypeError("hexToNumber: expected string, got " + typeof t);
        return BigInt(`0x${t}`)
    }

    function It(t) {
        if ("string" != typeof t) throw new TypeError("hexToBytes: expected string, got " + typeof t);
        if (t.length % 2) throw new Error("hexToBytes: received invalid unpadded hex" + t.length);
        const n = new Uint8Array(t.length / 2);
        for (let e = 0; e < n.length; e++) {
            const r = 2 * e, i = t.slice(r, r + 2), o = Number.parseInt(i, 16);
            if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
            n[e] = o
        }
        return n
    }

    function Ht(t) {
        return Bt(St(t))
    }

    function zt(t) {
        return t instanceof Uint8Array ? Uint8Array.from(t) : It(t)
    }

    function Nt(t) {
        if ("number" == typeof t && Number.isSafeInteger(t) && t > 0) return BigInt(t);
        if ("bigint" == typeof t && $t(t)) return t;
        throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")
    }

    function Tt(t, n = rt.P) {
        const e = t % n;
        return e >= J ? e : n + e
    }

    function Rt(t, n) {
        const {P: e} = rt;
        let r = t;
        for (; n-- > J;) r *= r, r %= e;
        return r
    }

    function kt(t, n = rt.P) {
        if (t === J || n <= J) throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);
        let e = Tt(t, n), r = n, i = J, o = Q;
        for (; e !== J;) {
            const t = r % e, n = i - o * (r / e);
            r = e, e = t, i = o, o = n
        }
        if (r !== Q) throw new Error("invert: does not exist");
        return Tt(i, n)
    }

    function Ct(t, n = !1) {
        const e = function (t) {
            const n = 8 * t.length - 8 * at, e = Ht(t);
            return n > 0 ? e >> BigInt(n) : e
        }(t);
        if (n) return e;
        const {n: r} = rt;
        return e >= r ? e - r : e
    }

    let Dt, Kt;

    class jt {
        constructor(t, n) {
            if (this.hashLen = t, this.qByteLen = n, "number" != typeof t || t < 2) throw new Error("hashLen must be a number");
            if ("number" != typeof n || n < 2) throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(t).fill(1), this.k = new Uint8Array(t).fill(0), this.counter = 0
        }

        hmac(...t) {
            return ln.hmacSha256(this.k, ...t)
        }

        hmacSync(...t) {
            return Kt(this.k, ...t)
        }

        checkSync() {
            if ("function" != typeof Kt) throw new dt("hmacSha256Sync needs to be set")
        }

        incr() {
            if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1
        }

        async reseed(t = new Uint8Array) {
            this.k = await this.hmac(this.v, Uint8Array.from([0]), t), this.v = await this.hmac(this.v), 0 !== t.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), t), this.v = await this.hmac(this.v))
        }

        reseedSync(t = new Uint8Array) {
            this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), t), this.v = this.hmacSync(this.v), 0 !== t.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), t), this.v = this.hmacSync(this.v))
        }

        async generate() {
            this.incr();
            let t = 0;
            const n = [];
            for (; t < this.qByteLen;) {
                this.v = await this.hmac(this.v);
                const e = this.v.slice();
                n.push(e), t += this.v.length
            }
            return Et(...n)
        }

        generateSync() {
            this.checkSync(), this.incr();
            let t = 0;
            const n = [];
            for (; t < this.qByteLen;) {
                this.v = this.hmacSync(this.v);
                const e = this.v.slice();
                n.push(e), t += this.v.length
            }
            return Et(...n)
        }
    }

    function $t(t) {
        return J < t && t < rt.n
    }

    function Vt(t) {
        return J < t && t < rt.P
    }

    function Lt(t, n, e, r = !0) {
        const {n: i} = rt, o = Ct(t, !0);
        if (!$t(o)) return;
        const s = kt(o, i), a = mt.BASE.multiply(o), c = Tt(a.x, i);
        if (c === J) return;
        const u = Tt(s * Tt(n + e * c, i), i);
        if (u === J) return;
        let f = new xt(c, u), h = (a.x === f.r ? 0 : 2) | Number(a.y & Q);
        return r && f.hasHighS() && (f = f.normalizeS(), h ^= 1), {sig: f, recovery: h}
    }

    function qt(t) {
        let n;
        if ("bigint" == typeof t) n = t; else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0) n = BigInt(t); else if ("string" == typeof t) {
            if (t.length !== 2 * at) throw new Error("Expected 32 bytes of private key");
            n = Bt(t)
        } else {
            if (!(t instanceof Uint8Array)) throw new TypeError("Expected valid private key");
            if (t.length !== at) throw new Error("Expected 32 bytes of private key");
            n = Ht(t)
        }
        if (!$t(n)) throw new Error("Expected private key: 0 < key < n");
        return n
    }

    function Ft(t) {
        return t instanceof mt ? (t.assertValidity(), t) : mt.fromHex(t)
    }

    function Mt(t) {
        if (t instanceof xt) return t.assertValidity(), t;
        try {
            return xt.fromDER(t)
        } catch (n) {
            return xt.fromCompact(t)
        }
    }

    function Yt(t) {
        const n = t instanceof Uint8Array, e = "string" == typeof t, r = (n || e) && t.length;
        return n ? r === ut || r === ft : e ? r === 2 * ut || r === 2 * ft : t instanceof mt
    }

    function Zt(t, n, e = !1) {
        if (Yt(t)) throw new TypeError("getSharedSecret: first arg must be private key");
        if (!Yt(n)) throw new TypeError("getSharedSecret: second arg must be public key");
        const r = Ft(n);
        return r.assertValidity(), r.multiply(qt(t)).toRawBytes(e)
    }

    function Wt(t) {
        return Ht(t.length > st ? t.slice(0, st) : t)
    }

    function Gt(t) {
        const n = Wt(t), e = Tt(n, rt.n);
        return Xt(e < J ? n : e)
    }

    function Xt(t) {
        return Ut(t)
    }

    function Jt(t, n, e) {
        if (null == t) throw new Error(`sign: expected valid message hash, not "${t}"`);
        const r = zt(t), i = qt(n), o = [Xt(i), Gt(r)];
        if (null != e) {
            !0 === e && (e = ln.randomBytes(st));
            const t = zt(e);
            if (t.length !== st) throw new Error(`sign: Expected ${st} bytes of extra data`);
            o.push(t)
        }
        return {seed: Et(...o), m: Wt(r), d: i}
    }

    function Qt(t, n) {
        const {sig: e, recovery: r} = t, {der: i, recovered: o} = Object.assign({canonical: !0, der: !0}, n),
            s = i ? e.toDERRawBytes() : e.toCompactRawBytes();
        return o ? [s, r] : s
    }

    const tn = {strict: !0};

    function nn(t) {
        return Tt(Ht(t), rt.n)
    }

    class en {
        constructor(t, n) {
            this.r = t, this.s = n, this.assertValidity()
        }

        static fromHex(t) {
            const n = zt(t);
            if (64 !== n.length) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${n.length}`);
            const e = Ht(n.subarray(0, 32)), r = Ht(n.subarray(32, 64));
            return new en(e, r)
        }

        assertValidity() {
            const {r: t, s: n} = this;
            if (!Vt(t) || !$t(n)) throw new Error("Invalid signature")
        }

        toHex() {
            return Ot(this.r) + Ot(this.s)
        }

        toRawBytes() {
            return It(this.toHex())
        }
    }

    class rn {
        constructor(t, n, e = ln.randomBytes()) {
            if (null == t) throw new TypeError(`sign: Expected valid message, not "${t}"`);
            this.m = zt(t);
            const {x: r, scalar: i} = this.getScalar(qt(n));
            if (this.px = r, this.d = i, this.rand = zt(e), 32 !== this.rand.length) throw new TypeError("sign: Expected 32 bytes of aux randomness")
        }

        getScalar(t) {
            const n = mt.fromPrivateKey(t), e = n.hasEvenY() ? t : rt.n - t;
            return {point: n, scalar: e, x: n.toRawX()}
        }

        initNonce(t, n) {
            return Ut(t ^ Ht(n))
        }

        finalizeNonce(t) {
            const n = Tt(Ht(t), rt.n);
            if (n === J) throw new Error("sign: Creation of signature failed. k is zero");
            const {point: e, x: r, scalar: i} = this.getScalar(n);
            return {R: e, rx: r, k: i}
        }

        finalizeSig(t, n, e, r) {
            return new en(t.x, Tt(n + e * r, rt.n)).toRawBytes()
        }

        error() {
            throw new Error("sign: Invalid signature produced")
        }

        async calc() {
            const {m: t, d: n, px: e, rand: r} = this, i = ln.taggedHash, o = this.initNonce(n, await i(fn.aux, r)), {
                    R: s,
                    rx: a,
                    k: c
                } = this.finalizeNonce(await i(fn.nonce, o, e, t)), u = nn(await i(fn.challenge, a, e, t)),
                f = this.finalizeSig(s, c, u, n);
            return await an(f, t, e) || this.error(), f
        }

        calcSync() {
            const {m: t, d: n, px: e, rand: r} = this, i = ln.taggedHashSync,
                o = this.initNonce(n, i(fn.aux, r)), {R: s, rx: a, k: c} = this.finalizeNonce(i(fn.nonce, o, e, t)),
                u = nn(i(fn.challenge, a, e, t)), f = this.finalizeSig(s, c, u, n);
            return cn(f, t, e) || this.error(), f
        }
    }

    function on(t, n, e) {
        const r = t instanceof en, i = r ? t : en.fromHex(t);
        return r && i.assertValidity(), {...i, m: zt(n), P: Ft(e)}
    }

    function sn(t, n, e, r) {
        const i = mt.BASE.multiplyAndAddUnsafe(n, qt(e), Tt(-r, rt.n));
        return !(!i || !i.hasEvenY() || i.x !== t)
    }

    async function an(t, n, e) {
        try {
            const {r: r, s: i, m: o, P: s} = on(t, n, e),
                a = nn(await ln.taggedHash(fn.challenge, Ut(r), s.toRawX(), o));
            return sn(r, s, i, a)
        } catch (t) {
            return !1
        }
    }

    function cn(t, n, e) {
        try {
            const {r: r, s: i, m: o, P: s} = on(t, n, e), a = nn(ln.taggedHashSync(fn.challenge, Ut(r), s.toRawX(), o));
            return sn(r, s, i, a)
        } catch (t) {
            if (t instanceof dt) throw t;
            return !1
        }
    }

    const un = {
        Signature: en, getPublicKey: function (t) {
            return mt.fromPrivateKey(t).toRawX()
        }, sign: async function (t, n, e) {
            return new rn(t, n, e).calc()
        }, verify: an, signSync: function (t, n, e) {
            return new rn(t, n, e).calcSync()
        }, verifySync: cn
    };
    mt.BASE._setWindowSize(8);
    const fn = {challenge: "BIP0340/challenge", aux: "BIP0340/aux", nonce: "BIP0340/nonce"}, hn = {}, ln = {
        bytesToHex: St,
        hexToBytes: It,
        concatBytes: Et,
        mod: Tt,
        invert: kt,
        isValidPrivateKey(t) {
            try {
                return qt(t), !0
            } catch (t) {
                return !1
            }
        },
        _bigintTo32Bytes: Ut,
        _normalizePrivateKey: qt,
        hashToPrivateKey: t => {
            t = zt(t);
            const n = at + 8;
            if (t.length < n || t.length > 1024) throw new Error("Expected valid bytes of private key as per FIPS 186");
            return Ut(Tt(Ht(t), rt.n - Q) + Q)
        },
        randomBytes: (t = 32) => X.getRandomValues(new Uint8Array(t)),
        randomPrivateKey: () => ln.hashToPrivateKey(ln.randomBytes(at + 8)),
        precompute(t = 8, n = mt.BASE) {
            const e = n === mt.BASE ? n : new mt(n.x, n.y);
            return e._setWindowSize(t), e.multiply(nt), e
        },
        sha256: async (...t) => {
            const n = await X.subtle.digest("SHA-256", Et(...t));
            return new Uint8Array(n)
        },
        hmacSha256: async (t, ...n) => {
            const e = await X.subtle.importKey("raw", t, {name: "HMAC", hash: {name: "SHA-256"}}, !1, ["sign"]),
                r = Et(...n), i = await X.subtle.sign("HMAC", e, r);
            return new Uint8Array(i)
        },
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        taggedHash: async (t, ...n) => {
            let e = hn[t];
            if (void 0 === e) {
                const n = await ln.sha256(Uint8Array.from(t, (t => t.charCodeAt(0))));
                e = Et(n, n), hn[t] = e
            }
            return ln.sha256(e, ...n)
        },
        taggedHashSync: (t, ...n) => {
            if ("function" != typeof Dt) throw new dt("sha256Sync is undefined, you need to set it");
            let e = hn[t];
            if (void 0 === e) {
                const n = Dt(Uint8Array.from(t, (t => t.charCodeAt(0))));
                e = Et(n, n), hn[t] = e
            }
            return Dt(e, ...n)
        },
        _JacobianPoint: yt
    };
    Object.defineProperties(ln, {
        sha256Sync: {
            configurable: !1, get: () => Dt, set(t) {
                Dt || (Dt = t)
            }
        }, hmacSha256Sync: {
            configurable: !1, get: () => Kt, set(t) {
                Kt || (Kt = t)
            }
        }
    });
    var dn = Object.freeze({
        __proto__: null, CURVE: rt, Point: mt, Signature: xt, getPublicKey: function (t, n = !1) {
            return mt.fromPrivateKey(t).toRawBytes(n)
        }, getSharedSecret: Zt, recoverPublicKey: function (t, n, e, r = !1) {
            return mt.fromSignature(t, n, e).toRawBytes(r)
        }, schnorr: un, sign: async function (t, n, e = {}) {
            const {seed: r, m: i, d: o} = Jt(t, n, e.extraEntropy), s = new jt(ct, at);
            let a;
            for (await s.reseed(r); !(a = Lt(await s.generate(), i, o, e.canonical));) await s.reseed();
            return Qt(a, e)
        }, signSync: function (t, n, e = {}) {
            const {seed: r, m: i, d: o} = Jt(t, n, e.extraEntropy), s = new jt(ct, at);
            let a;
            for (s.reseedSync(r); !(a = Lt(s.generateSync(), i, o, e.canonical));) s.reseedSync();
            return Qt(a, e)
        }, utils: ln, verify: function (t, n, e, r = tn) {
            let i;
            try {
                i = Mt(t), n = zt(n)
            } catch (t) {
                return !1
            }
            const {r: o, s: s} = i;
            if (r.strict && i.hasHighS()) return !1;
            const a = Ct(n);
            let c;
            try {
                c = Ft(e)
            } catch (t) {
                return !1
            }
            const {n: u} = rt, f = kt(s, u), h = Tt(a * f, u), l = Tt(o * f, u),
                d = mt.BASE.multiplyAndAddUnsafe(c, h, l);
            return !!d && Tt(d.x, u) === o
        }
    });
    const wn = new TextEncoder,
        yn = [{name: "base58", charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}, {
            name: "base64",
            charset: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        }, {name: "base64url", charset: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];

    function gn(t) {
        for (const n of yn) if (n.name === t) return n.charset;
        throw TypeError("Charset does not exist: " + t)
    }

    const pn = {
            encode: function (t, n, e = !1) {
                "string" == typeof t && (t = wn.encode(t));
                const r = gn(n), i = r.length, o = [];
                let s, a, c, u = "", f = 0;
                for (s = 0; s < t.length; s++) for (f = 0, a = t[s], u += a > 0 || (u.length ^ s) > 0 ? "" : "1"; f in o || a > 0;) c = o[f], c = c > 0 ? 256 * c + a : a, a = c / i | 0, o[f] = c % i, f++;
                for (; f-- > 0;) u += r[o[f]];
                return e && u.length % 4 > 0 ? u + "=".repeat(4 - u.length % 4) : u
            }, decode: function (t, n) {
                const e = gn(n), r = e.length, i = [], o = [];
                t = t.replace("=", "");
                let s, a, c, u = 0;
                for (s = 0; s < t.length; s++) {
                    if (u = 0, a = e.indexOf(t[s]), a < 0) throw new Error(`Character range out of bounds: ${a}`);
                    for (a > 0 || (o.length ^ s) > 0 || o.push(0); u in i || a > 0;) c = i[u], c = c > 0 ? c * r + a : a, a = c >> 8, i[u] = c % 256, u++
                }
                for (; u-- > 0;) o.push(i[u]);
                return new Uint8Array(o)
            }
        }, mn = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", bn = [996825010, 642813549, 513874426, 1027748829, 705979059],
        An = {BECH32: "bech32", BECH32M: "bech32m"};

    function xn(t) {
        switch (t) {
            case An.BECH32:
                return 1;
            case An.BECH32M:
                return 734539939;
            default:
                throw new Error(`Unrecognized encoding: ${t}`)
        }
    }

    function En(t) {
        let n = 1;
        for (let e = 0; e < t.length; ++e) {
            const r = n >> 25;
            n = (33554431 & n) << 5 ^ t[e];
            for (let t = 0; t < 5; ++t) (r >> t & 1) > 0 && (n ^= bn[t])
        }
        return n
    }

    function vn(t) {
        const n = [];
        let e;
        for (e = 0; e < t.length; ++e) n.push(t.charCodeAt(e) >> 5);
        for (n.push(0), e = 0; e < t.length; ++e) n.push(31 & t.charCodeAt(e));
        return n
    }

    function Sn(t, n, e, r = !0) {
        const i = [];
        let o = 0, s = 0;
        const a = (1 << e) - 1, c = (1 << n + e - 1) - 1;
        for (const r of t) {
            if (r < 0 || r >> n > 0) return [];
            for (o = (o << n | r) & c, s += n; s >= e;) s -= e, i.push(o >> s & a)
        }
        if (r) s > 0 && i.push(o << e - s & a); else if (s >= n || (o << e - s & a) > 0) return [];
        return i
    }

    function Pn(t, n, e) {
        const r = n.concat(function (t, n, e) {
            const r = En(vn(t).concat(n).concat([0, 0, 0, 0, 0, 0])) ^ xn(e), i = [];
            for (let t = 0; t < 6; ++t) i.push(r >> 5 * (5 - t) & 31);
            return i
        }(t, n, e));
        let i = t + "1";
        for (let t = 0; t < r.length; ++t) i += mn.charAt(r[t]);
        return i
    }

    function On(t, n) {
        const e = n > 0 ? "bech32m" : "bech32";
        if (!function (t) {
            let n, e, r = !1, i = !1;
            for (n = 0; n < t.length; ++n) {
                if (e = t.charCodeAt(n), e < 33 || e > 126) return !1;
                e >= 97 && e <= 122 && (r = !0), e >= 65 && e <= 90 && (i = !0)
            }
            return !(r && i)
        }(t)) return {hrp: null, data: [255]};
        if (!function (t) {
            const n = t.lastIndexOf("1");
            return !(n < 1 || n + 7 > t.length || t.length > 90)
        }(t = t.toLowerCase())) return {hrp: null, data: [255]};
        const r = [], i = t.lastIndexOf("1"), o = t.substring(0, i);
        for (let n = i + 1; n < t.length; ++n) {
            const e = mn.indexOf(t.charAt(n));
            if (-1 === e) return {hrp: null, data: [255]};
            r.push(e)
        }
        return function (t, n, e) {
            return En(vn(t).concat(n)) === xn(e)
        }(o, r, e) ? {hrp: o, data: r.slice(0, r.length - 6)} : {hrp: null, data: [255]}
    }

    function Un(t, n = 0) {
        const e = t.split("1", 1)[0], {hrp: r, data: i} = On(t, n), o = Sn(i.slice(1), 5, 8, !1), s = o.length;
        switch (!0) {
            case e !== r:
                throw new Error("Returned hrp string is invalid.");
            case null === o || s < 2 || s > 40:
                throw new Error("Decoded string is invalid or out of spec.");
            case i[0] > 16:
                throw new Error("Returned version bit is out of range.");
            case 0 === i[0] && 20 !== s && 32 !== s:
                throw new Error("Decoded string does not match version 0 spec.");
            case 0 === i[0] && 0 !== n:
            case 0 !== i[0] && 1 !== n:
                throw new Error("Decoded version bit does not match.");
            default:
                return Uint8Array.from(o)
        }
    }

    const _n = {
        encode: function (t, n = "bch", e = 0) {
            const r = Pn(n, [e, ...Sn([...t], 8, 5)], e > 0 ? "bech32m" : "bech32");
            return Un(r, e), r
        }, decode: Un
    }, Bn = new TextEncoder, In = new TextDecoder;

    function Hn(t) {
        return Bn.encode(t)
    }

    function zn(t) {
        const n = [];
        let e, r = 0;
        if (t.length % 2 > 0) throw new Error(`Invalid hex string length: ${t.length}`);
        for (e = 0; e < t.length; e += 2) n[r] = parseInt(t.slice(e, e + 2), 16), r += 1;
        return Uint8Array.from(n)
    }

    function Nn(t) {
        const n = [];
        for (; t > 0;) {
            const e = 255 & t;
            n.push(e), t = (t - e) / 256
        }
        return Uint8Array.from(n)
    }

    function Tn(t) {
        const n = [];
        for (; t > 0n;) {
            const e = 0xffn & t;
            n.push(Number(e)), t = (t - e) / 256n
        }
        return Uint8Array.from(n)
    }

    function Rn(t) {
        return In.decode(t)
    }

    function kn(t) {
        let n, e = 0;
        for (n = t.length - 1; n >= 0; n--) e = 256 * e + t[n];
        return Number(e)
    }

    function Cn(t) {
        let n, e = 0n;
        for (n = t.length - 1; n >= 0; n--) e = 256n * e + BigInt(t[n]);
        return BigInt(e)
    }

    async function Dn(t) {
        return crypto.subtle.digest("SHA-256", t).then((t => new Uint8Array(t)))
    }

    async function Kn(t) {
        return Dn(await Dn(t))
    }

    const {crypto: jn} = globalThis;

    class $n extends Uint8Array {
        static {
            this.num = (t, n, e = "le") => new $n(Nn(t), n, e)
        }
        static {
            this.big = (t, n, e = "le") => new $n(Tn(t), n, e)
        }

        static async b58check(t) {
            const n = pn.decode(t, "base58");
            return new $n(await async function (t) {
                const n = t.slice(0, -4), e = t.slice(-4);
                if ((await Kn(n)).slice(0, 4).toString() !== e.toString()) throw new Error("Invalid checksum!");
                return n
            }(n))
        }

        static {
            this.buff = (t, n) => new $n(function (t) {
                if (t instanceof ArrayBuffer) return new Uint8Array(t);
                if (t instanceof Uint8Array) return t;
                const n = typeof t;
                switch (n) {
                    case"bigint":
                        return Tn(t);
                    case"boolean":
                        return Uint8Array.of(t);
                    case"number":
                        return Nn(t);
                    case"string":
                        return null !== t.match(/^(02|03)*[0-9a-fA-F]{64}$/) ? zn(t) : Bn.encode(t);
                    default:
                        throw TypeError("Unsupported format:" + n)
                }
            }(t), n)
        }
        static {
            this.raw = (t, n) => new $n(t, n)
        }
        static {
            this.str = (t, n) => new $n(Hn(t), n)
        }
        static {
            this.hex = (t, n) => new $n(zn(t), n)
        }
        static {
            this.json = t => new $n(Hn(JSON.stringify(t)))
        }
        static {
            this.base64 = t => new $n(pn.decode(t, "base64"))
        }
        static {
            this.b64url = t => new $n(pn.decode(t, "base64url"))
        }
        static {
            this.bech32 = (t, n) => new $n(_n.decode(t, n))
        }

        constructor(t, n = null, e = "be") {
            if (null !== n) {
                const e = new Uint8Array(n).fill(0);
                e.set(new Uint8Array(t)), t = e.buffer
            }
            return super(t = "le" === e ? new Uint8Array(t).reverse() : t), this
        }

        get num() {
            return this.toNum()
        }

        get big() {
            return this.toBig()
        }

        get arr() {
            return this.toArr()
        }

        get str() {
            return this.toStr()
        }

        get hex() {
            return this.toHex()
        }

        get raw() {
            return new Uint8Array(this)
        }

        get hash() {
            return this.toHash()
        }

        get id() {
            return this.toHash().then((t => new $n(t).hex))
        }

        toNum(t = "le") {
            return kn("le" === t ? this.reverse() : this)
        }

        toBig(t = "le") {
            return Cn("le" === t ? this.reverse() : this)
        }

        async toHash() {
            return jn.subtle.digest("SHA-256", this.raw).then((t => new Uint8Array(t)))
        }

        async tob58check() {
            return pn.encode(await async function (t) {
                const n = await Kn(t);
                return Uint8Array.of(...t, ...n.slice(0, 4))
            }(this), "base58")
        }

        toArr() {
            return Array.from(this)
        }

        toStr() {
            return Rn(this)
        }

        toHex() {
            return function (t) {
                const n = [];
                let e;
                for (e = 0; e < t.length; e++) n.push(t[e].toString(16).padStart(2, "0"));
                return n.join("")
            }(this)
        }

        toJson() {
            return JSON.parse(Rn(this))
        }

        toBytes() {
            return new Uint8Array(this)
        }

        toB64url() {
            return pn.encode(this, "base64url")
        }

        toBase64(t) {
            return pn.encode(this, "base64", t)
        }

        toBech32(t, n) {
            return _n.encode(this, t, n)
        }

        prepend(t) {
            return $n.of(...t, ...this)
        }

        append(t) {
            return $n.of(...this, ...t)
        }

        slice(t, n) {
            return new $n(new Uint8Array(this).slice(t, n))
        }

        reverse() {
            return new $n(new Uint8Array(this).reverse())
        }

        write(t, n) {
            this.set(t, n)
        }

        prependVarint(t = this.length) {
            return $n.of(...$n.readVarint(t), ...this)
        }

        static from(t) {
            return new $n(Uint8Array.from(t))
        }

        static of(...t) {
            return new $n(Uint8Array.of(...t))
        }

        static join(t) {
            let n, e = 0;
            const r = t.reduce(((t, n) => t + n.length), 0), i = new Uint8Array(r);
            for (const r of t) for (n = 0; n < r.length; e++, n++) i[e] = r[n];
            return new $n(i, r)
        }

        static readVarint(t) {
            if (t < 253) return $n.num(t, 1);
            if (t < 65536) return $n.of(253, ...$n.num(t, 2));
            if (t < 4294967296) return $n.of(254, ...$n.num(t, 4));
            if (t < 0x10000000000000000) return $n.of(255, ...$n.num(t, 8));
            throw new Error(`Value is too large: ${t}`)
        }

        static random(t = 32) {
            return new $n(jn.getRandomValues(new Uint8Array(t)))
        }

        static {
            this.encode = Hn
        }
        static {
            this.decode = Rn
        }

        static normalize(t, n) {
            if (t instanceof Uint8Array) return t;
            if ("string" == typeof t) return $n.hex(t, n).toBytes();
            if ("number" == typeof t) return $n.num(t, n).toBytes();
            if ("bigint" == typeof t) return $n.big(t, n).toBytes();
            throw TypeError("Unrecognized format: " + typeof t)
        }

        static serialize(t) {
            if ("string" == typeof t) return $n.str(t).toBytes();
            if ("object" == typeof t) {
                if (t instanceof Uint8Array) return t;
                try {
                    return $n.json(t).toBytes()
                } catch {
                    throw TypeError("Object is not serializable.")
                }
            }
            throw TypeError("Unrecognized format: " + typeof t)
        }

        static revitalize(t) {
            if (t instanceof Uint8Array && (t = Rn(t)), "string" == typeof t) try {
                return JSON.parse(t)
            } catch {
                return t
            }
            return t
        }
    }

    const Vn = globalThis.crypto;

    async function Ln(t, n) {
        return Zt($n.normalize(t), $n.normalize(n), !0)
    }

    async function qn(t) {
        return Vn.subtle.importKey("raw", $n.normalize(t), {name: "AES-CBC"}, !0, ["encrypt", "decrypt"])
    }

    const Fn = {
        ecdh: Ln, import: qn, export: async function (t) {
            return Vn.subtle.exportKey("raw", t).then((t => new Uint8Array(t)))
        }, hmac: async function (t, n = "SHA-256") {
            const e = {name: "HMAC", hash: n};
            return Vn.subtle.importKey("raw", $n.normalize(t), e, !1, ["sign", "verify"])
        }, shared: async function (t, n) {
            return qn((await Ln(t, n)).slice(1, 33))
        }, generate: async function () {
            return qn($n.random(32))
        }, normalize: async function (t) {
            return t instanceof CryptoKey ? t : Fn.import(t)
        }
    };

    class Mn extends Uint8Array {
        static {
            this.N = rt.n
        }

        static mod(t, n = Mn.N) {
            return ln.mod(t, n)
        }

        static {
            this.isField = t => t instanceof Mn
        }

        static normalize(t) {
            return t = Zn(t), t = Mn.mod(t), t = ln._normalizePrivateKey(t), $n.big(t, 32).raw
        }

        static validate(t) {
            return ln.isValidPrivateKey(t)
        }

        constructor(t) {
            super(t = Mn.normalize(t))
        }

        get buff() {
            return new $n(this)
        }

        get raw() {
            return this
        }

        get num() {
            return this.buff.toBig()
        }

        get point() {
            return Yn.fromNum(this.num)
        }

        get hasOddY() {
            return this.point.hasOddY
        }

        get negated() {
            return this.hasOddY ? this.negate() : this
        }

        gt(t) {
            return new Mn(t).num > this.num
        }

        lt(t) {
            return new Mn(t).num < this.num
        }

        eq(t) {
            return new Mn(t).num === this.num
        }

        ne(t) {
            return new Mn(t).num !== this.num
        }

        add(t) {
            const n = new Mn(t);
            return new Mn(this.num + n.num)
        }

        sub(t) {
            const n = new Mn(t);
            return new Mn(this.num - n.num)
        }

        mul(t) {
            const n = new Mn(t);
            return new Mn(this.num * n.num)
        }

        pow(t, n = Mn.N - 1n) {
            const e = new Mn(t), r = Mn.mod(e.num, n);
            return new Mn(this.num ** r)
        }

        div(t) {
            const n = new Mn(t), e = this.pow(n.num, Mn.N - 2n);
            return new Mn(this.num * e.num)
        }

        negate() {
            return new Mn(Mn.N - this.num)
        }
    }

    class Yn {
        static {
            this.N = rt.n
        }

        static validate(t) {
            try {
                t = Zn(t);
                const n = $n.big(t).toHex();
                return mt.fromHex(n).assertValidity(), !0
            } catch {
                return !1
            }
        }

        static fromNum(t) {
            t = Zn(t);
            const n = ln.mod(t, Yn.N), e = mt.BASE.multiply(n);
            return new Yn(e.x, e.y)
        }

        static fromX(t) {
            t = Zn(t);
            const n = $n.big(t).toHex();
            return Yn.from(mt.fromHex(n))
        }

        static from(t) {
            return new Yn(t.x, t.y)
        }

        constructor(t, n) {
            this.__p = new mt(t, n), this.__x = this.__p.x, this.__y = this.__p.y, this.__p.assertValidity()
        }

        get p() {
            return this.__p
        }

        get buff() {
            return new $n(this.rawX.slice(1))
        }

        get hex() {
            return this.buff.hex
        }

        get hasOddY() {
            return !this.__p.hasEvenY()
        }

        get rawX() {
            const t = this.__p.hasEvenY() ? 2 : 3, n = $n.big(this.__x);
            return Uint8Array.of(t, ...n)
        }

        get rawY() {
            return $n.big(this.__y)
        }

        get x() {
            return this.__x
        }

        get y() {
            return this.__y
        }

        eq(t) {
            return t instanceof Yn ? this.p.equals(new mt(t.x, t.y)) : t instanceof Uint8Array ? this.x.toString() === t.toString() : "number" == typeof t ? BigInt(t) === this.x : t === this.x
        }

        add(t) {
            return t instanceof Yn ? Yn.from(this.p.add(t.p)) : Yn.from(this.p.add(Yn.fromNum(t).p))
        }

        sub(t) {
            return t instanceof Yn ? Yn.from(this.p.subtract(t.p)) : Yn.from(this.p.subtract(Yn.fromNum(t).p))
        }

        mul(t) {
            return t instanceof Yn ? Yn.from(this.p.multiply(t.x)) : Yn.from(this.p.multiply(Zn(t)))
        }

        negate() {
            return Yn.from(this.__p.negate())
        }
    }

    function Zn(t) {
        if (t instanceof Uint8Array) return $n.raw(t).big;
        if ("string" == typeof t) return $n.hex(t).big;
        if ("number" == typeof t) return BigInt(t);
        if ("bigint" == typeof t) return t;
        throw TypeError("Invalid input type:" + typeof t)
    }

    function Wn(t) {
        let n = 0n;
        for (let e = t.length - 1; e >= 0; e--) n = 256n * n + BigInt(t[e]);
        return BigInt(n)
    }

    function Gn(t, n = 0) {
        const e = [];
        for (; t > 0;) {
            const n = 0xffn & t;
            e.push(n), t = (t - n) / 256n
        }
        let r = Uint8Array.from(e.map((t => Number(t))));
        if (0 !== n) {
            const t = new Uint8Array(n);
            t.set(r), r = t
        }
        return r
    }

    const Xn = [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n, 13n, 14n, 15n, 7n, 4n, 13n, 1n, 10n, 6n, 15n, 3n, 12n, 0n, 9n, 5n, 2n, 14n, 11n, 8n, 3n, 10n, 14n, 4n, 9n, 15n, 8n, 1n, 2n, 7n, 0n, 6n, 13n, 11n, 5n, 12n, 1n, 9n, 11n, 10n, 0n, 8n, 12n, 4n, 13n, 3n, 7n, 15n, 14n, 5n, 6n, 2n, 4n, 0n, 5n, 9n, 7n, 12n, 2n, 10n, 14n, 1n, 3n, 8n, 11n, 6n, 15n, 13n],
        Jn = [5n, 14n, 7n, 0n, 9n, 2n, 11n, 4n, 13n, 6n, 15n, 8n, 1n, 10n, 3n, 12n, 6n, 11n, 3n, 7n, 0n, 13n, 5n, 10n, 14n, 15n, 8n, 12n, 4n, 9n, 1n, 2n, 15n, 5n, 1n, 3n, 7n, 14n, 6n, 9n, 11n, 8n, 12n, 2n, 10n, 0n, 4n, 13n, 8n, 6n, 4n, 1n, 3n, 11n, 15n, 0n, 5n, 12n, 2n, 13n, 9n, 7n, 10n, 14n, 12n, 15n, 10n, 4n, 1n, 5n, 8n, 7n, 6n, 2n, 13n, 14n, 0n, 3n, 9n, 11n],
        Qn = [11n, 14n, 15n, 12n, 5n, 8n, 7n, 9n, 11n, 13n, 14n, 15n, 6n, 7n, 9n, 8n, 7n, 6n, 8n, 13n, 11n, 9n, 7n, 15n, 7n, 12n, 15n, 9n, 11n, 7n, 13n, 12n, 11n, 13n, 6n, 7n, 14n, 9n, 13n, 15n, 14n, 8n, 13n, 6n, 5n, 12n, 7n, 5n, 11n, 12n, 14n, 15n, 14n, 15n, 9n, 8n, 9n, 14n, 5n, 6n, 8n, 6n, 5n, 12n, 9n, 15n, 5n, 11n, 6n, 8n, 13n, 12n, 5n, 12n, 13n, 14n, 11n, 8n, 5n, 6n],
        te = [8n, 9n, 9n, 11n, 13n, 15n, 15n, 5n, 7n, 7n, 8n, 11n, 14n, 14n, 12n, 6n, 9n, 13n, 15n, 7n, 12n, 8n, 9n, 11n, 7n, 7n, 12n, 7n, 6n, 15n, 13n, 11n, 9n, 7n, 15n, 11n, 8n, 6n, 6n, 14n, 12n, 13n, 5n, 14n, 13n, 13n, 7n, 5n, 15n, 5n, 8n, 11n, 14n, 14n, 6n, 14n, 6n, 9n, 12n, 9n, 12n, 5n, 15n, 8n, 8n, 5n, 12n, 9n, 12n, 5n, 14n, 6n, 8n, 13n, 6n, 5n, 15n, 13n, 11n, 11n],
        ne = [0n, 0x5a827999n, 0x6ed9eba1n, 0x8f1bbcdcn, 0xa953fd4en],
        ee = [0x50a28be6n, 0x5c4dd124n, 0x6d703ef3n, 0x7a6d76e9n, 0n];

    function re(t, n, e, r) {
        switch (!0) {
            case 0n === r:
                return t ^ n ^ e;
            case 1n === r:
                return t & n | ~t & e;
            case 2n === r:
                return (t | ~n) ^ e;
            case 3n === r:
                return t & e | n & ~e;
            case 4n === r:
                return t ^ (n | ~e);
            default:
                throw new TypeError("Unknown I value: " + String(r))
        }
    }

    function ie(t, n) {
        return 0xffffffffn & (t << n | (0xffffffffn & t) >> 32n - n)
    }

    function oe(t, n, e, r, i, o) {
        const s = [];
        let a, c, u, f, h, l, d, w = t, y = n, g = e, p = r, m = i, b = t, A = n, x = e, E = r, v = i;
        for (let t = 0; t < 16; t++) {
            const n = Wn(o.slice(4 * t, 4 * (t + 1)));
            s.push(n)
        }
        for (let t = 0; t < 80; t++) a = BigInt(t) >> 4n, f = s[Number(Xn[t])], h = ne[Number(a)], l = s[Number(Jn[t])], d = ee[Number(a)], w = ie(w + re(y, g, p, a) + f + h, Qn[t]) + m, c = m, m = p, p = ie(g, 10n), g = y, y = w, w = c, b = ie(b + re(A, x, E, 4n - a) + l + d, te[t]) + v, u = v, v = E, E = ie(x, 10n), x = A, A = b, b = u;
        return [n + g + E, e + p + v, r + m + b, i + w + A, t + y + x]
    }

    const se = globalThis.crypto;

    async function ae(t, n = "SHA-256", e = 1, r = (t => t)) {
        let i, o = t instanceof ArrayBuffer ? t : $n.normalize(t).buffer;
        for (i = 0; i < e; i++) o = await se.subtle.digest(n, o), r(o);
        return new Uint8Array(o)
    }

    async function ce(t) {
        return ae(t, "SHA-256")
    }

    function ue(t) {
        return function (t) {
            let n = [0x67452301n, 0xefcdab89n, 0x98badcfen, 0x10325476n, 0xc3d2e1f0n];
            for (let e = 0; e < t.length >> 6; e++) n = oe(...n, t.slice(64 * e, 64 * (e + 1)));
            const e = [128, ...new Array(119 - t.length & 63).fill(0)],
                r = Uint8Array.from([...t.slice(-64 & t.length), ...e, ...Gn(BigInt(8 * t.length), 8)]);
            for (let t = 0; t < r.length >> 6; t++) n = oe(...n, r.slice(64 * t, 64 * (t + 1)));
            const i = [];
            for (let t = 0; t < n.length; t++) {
                const e = 0xffffffffn & n[t];
                i.push(...Gn(e, 4))
            }
            return Uint8Array.from(i)
        }(t = $n.normalize(t))
    }

    const fe = {
        data: async function (t) {
            return ce($n.serialize(t)).then((t => new Uint8Array(t)))
        }, digest: ae, ripe160: ue, sha256: ce, sha512: async function (t) {
            return ae(t, "SHA-512")
        }, hash160: async function (t) {
            return ue(await ce(t))
        }, hash256: async function (t) {
            return ae(t, "SHA-256", 2)
        }, hmac256: async function (t, n) {
            const e = await Fn.hmac(t, "SHA-256");
            return se.subtle.sign("HMAC", e, $n.normalize(n)).then((t => new Uint8Array(t)))
        }, hmac512: async function (t, n) {
            const e = await Fn.hmac(t, "SHA-512");
            return se.subtle.sign("HMAC", e, $n.normalize(n)).then((t => new Uint8Array(t)))
        }
    }, he = [1, 2, 3, 129, 130, 131];

    function le(t, n) {
        if (n) throw new Error(t);
        return !1
    }

    const de = 192, we = new TextEncoder;

    function ye(t, n) {
        let e = new Mn(t);
        return e.point.hasOddY && (e = e.negate()), e.add(n)
    }

    function ge(t, n) {
        return Yn.fromX(t).add(n).rawX
    }

    async function pe(t, n = [], e = !1) {
        const r = _.normalize(t), i = n.length > 0 ? await me(n) : new Uint8Array,
            o = e ? dn.getPublicKey(r, !0).slice(1) : r, s = await Ee(o, i);
        if (e) return [_.raw(ye(r, s)).hex, 0];
        {
            const t = _.raw(ge(r, s));
            return [t.slice(1).hex, t.slice(0, 1).num]
        }
    }

    async function me(t) {
        return Se(t).then((t => _.hex(t[0])))
    }

    async function be(t) {
        const n = await fe.sha256(we.encode(t));
        return Uint8Array.of(...n, ...n)
    }

    // Rarity Garden Hack
    async function Ae(t, n = de) {

        let leafed = await be("TapLeaf");
        const uint8 = new Uint8Array(leafed.length);

        for(let i = 0; i < leafed.length; i++)
        {
            uint8[i] = leafed[i];
        }

        let tn = function (t = 192) {
            return 254 & t
        }(n);

        const uint8_tn = new Uint8Array(1);
        uint8_tn[0] = tn;

        let normed = _.normalize(t);
        const uint8_normed = new Uint8Array(normed.length);

        for(let i = 0; i < uint8_normed.length; i++)
        {
            uint8_normed[i] = normed[i];
        }

        var uint8_new = new Uint8Array(uint8.length + uint8_normed.length + uint8_tn.length);
        uint8_new.set(uint8);
        uint8_new.set(uint8_tn, uint8.length);
        uint8_new.set(uint8_normed, uint8.length + uint8_tn.length);

        return fe.sha256(uint8_new).then((t => _.raw(t).hex))
    }

    async function Ae2(t, n = de) {
        return fe.sha256(Uint8Array.of(...await be("TapLeaf"), function (t = 192) {
            return 254 & t
        }(n), ..._.normalize(t))).then((t => _.raw(t).hex))
    }

    async function xe(t, n) {
        return n < t && ([t, n] = [n, t]), fe.sha256(Uint8Array.of(...await be("TapBranch"), ..._.hex(t).raw, ..._.hex(n).raw)).then((t => _.raw(t).hex))
    }

    async function Ee(t, n) {
        return fe.sha256(Uint8Array.of(...await be("TapTweak"), ..._.normalize(t), ..._.normalize(n)))
    }

    async function ve(t, n, e) {
        const r = new B(_.normalize(n)), [i, o] = (s = r.read(1).num) % 2 == 0 ? [s, 2] : [s - 1, 3];
        var s;
        const a = r.read(32), c = _.of(o, ..._.normalize(t)), u = [];
        let f = e;
        for (; r.size >= 32;) u.push(r.read(32).hex);
        if (0 !== r.size) throw new Error("Invalid control block size!");
        for (const t of u) f = await xe(f, t);
        const h = ge(a, await Ee(a, _.hex(f)));
        return _.raw(h).hex === _.raw(c).hex
    }

    async function Se(t, n = null, e = []) {
        const r = [], i = [];
        for (let i = 0; i < t.length; i++) {
            const o = t[i];
            if (Array.isArray(o)) {
                const [t, i, s] = await Se(o, n);
                r.push(t), n = i, e.push(...s)
            } else r.push(o)
        }
        if (1 === r.length) return [r[0], n, e];
        r.sort(), r.length % 2 != 0 && r.push(r[r.length - 1]);
        for (let t = 0; t < r.length - 1; t += 2) {
            const o = await xe(r[t], r[t + 1]);
            i.push(o), "string" == typeof n && (n === r[t] ? (e.push(r[t + 1]), n = o) : n === r[t + 1] && (e.push(r[t]), n = o))
        }
        return Se(i, n, e)
    }

    const Pe = [0, 1, 2, 3, 129, 130, 131];

    async function Oe(t, n, e = {}) {
        ("string" == typeof t || t instanceof Uint8Array) && (t = L(t));
        const {
            extention: r,
            sigflag: i = 0,
            extflag: o = 0,
            key_version: s = 0,
            separator_pos: a = 4294967295
        } = e, {version: c, input: u = [], output: f = [], locktime: h} = t;
        if (n >= u.length) throw new Error("Index out of bounds: " + String(n));
        if (!Pe.includes(i)) throw new Error("Invalid hash type: " + String(i));
        if (o < 0 || o > 127) throw new Error("Extention flag out of range: " + String(o));
        const {txid: l, vout: d, sequence: w, witness: y = []} = u[n], g = 128 == (128 & i),
            p = await async function (t) {
                if (void 0 === t) return;
                if (t.length < 2) return;
                let n = t.at(-1);
                "string" == typeof n && (n = _.hex(n));
                if (n instanceof Uint8Array && 80 === n[0]) return _.raw(n).prefixSize("be").digest;
                return
            }(y), m = 2 * (o + (void 0 !== r ? 1 : 0)) + (void 0 !== p ? 1 : 0),
            b = [await be("TapSighash"), _.num(0, 1), _.num(i, 1), k(c), V(h)];
        if (!g) {
            const t = u.map((t => Ue(t)));
            b.push(await async function (t) {
                const n = [];
                for (const {txid: e, vout: r} of t) n.push(C(e)), n.push(D(r));
                return fe.sha256(_.join(n))
            }(u), await async function (t) {
                const n = [];
                for (const {value: e} of t) n.push(j(e));
                return fe.sha256(_.join(n))
            }(t), await async function (t) {
                const n = [];
                for (const {scriptPubKey: e} of t) n.push(N(e));
                return fe.sha256(_.join(n))
            }(t), await async function (t) {
                const n = [];
                for (const {sequence: e} of t) n.push(K(e));
                return fe.sha256(_.join(n))
            }(u))
        }
        if (((3 & i) < 2 || (3 & i) > 3) && b.push(await async function (t) {
            const n = [];
            for (const {value: e, scriptPubKey: r} of t) n.push(j(e)), n.push(N(r));
            return fe.sha256(_.join(n))
        }(f)), b.push(_.num(m, 1)), g) {
            const {value: t, scriptPubKey: e} = Ue(u[n]);
            b.push(C(l), D(d), j(t), N(e), K(w))
        } else b.push(_.num(n, 4).reverse());
        return void 0 !== p && b.push(p), 3 == (3 & i) && b.push(await async function (t) {
            return fe.sha256(_.of(...j(t.value), ...N(t.scriptPubKey)))
        }(f[n])), void 0 !== r && b.push(_.normalize(r), _.num(s), _.num(a, 4)), fe.sha256(_.join(b))
    }

    function Ue(t) {
        if (void 0 === t.prevout) throw new Error("Prevout data missing for input: " + String(t.txid));
        return t.prevout
    }

    const _e = {
        encode: N, decode: function (t) {
            return function (t, n = "asm") {
                const e = new B(t), r = [], i = e.size;
                let o, s, a, c = 0;
                for (; c < i;) switch (o = e.read(1).num, s = W(o), c++, s) {
                    case"varint":
                        r.push(e.read(o).toHex()), c += o;
                        break;
                    case"pushdata1":
                        a = e.read(1).reverse().num, r.push(e.read(a).toHex()), c += a + 1;
                        break;
                    case"pushdata2":
                        a = e.read(2).reverse().num, r.push(e.read(a).toHex()), c += a + 2;
                        break;
                    case"pushdata4":
                        a = e.read(4).reverse().num, r.push(e.read(a).toHex()), c += a + 4;
                        break;
                    case"opcode":
                        if (!G(o)) throw new Error(`Invalid OPCODE: ${o}`);
                        "asm" === n ? r.push(H(o)) : r.push(o);
                        break;
                    default:
                        throw new Error(`Word type undefined: ${o}`)
                }
                return r
            }(_.normalize(t))
        }
    }, Be = {
        segwit: {
            hash: async function (t, n, e, r, i) {
                if (!he.includes(i)) throw new Error("Invalid hash type: " + String(i));
                const {version: o, input: s, output: a, locktime: c} = t, {txid: u, vout: f, sequence: h} = s[n],
                    l = i > 128, d = [k(o)];
                return d.push(await async function (t, n) {
                    if (!0 === n) return _.num(0, 32);
                    const e = [];
                    for (const {txid: n, vout: r} of t) e.push(C(n)), e.push(D(r));
                    return fe.hash256(_.join(e))
                }(s, l), await async function (t, n) {
                    if (1 !== n) return _.num(0, 32);
                    const e = [];
                    for (const {sequence: n} of t) e.push(K(n));
                    return fe.hash256(_.join(e))
                }(s, i), C(u), D(f), N(r, !0), j(e), K(h), await async function (t, n, e) {
                    const r = [];
                    if (1 === e) {
                        for (const {value: n, scriptPubKey: e} of t) r.push(j(n)), r.push(N(e));
                        return fe.hash256(_.join(r))
                    }
                    if (3 === e && n < t.length) {
                        const {value: e, scriptPubKey: i} = t[n];
                        return r.push(j(e)), r.push(N(i)), fe.hash256(_.join(r))
                    }
                    return _.num(0, 32)
                }(a, n, i), V(c), _.num(i, 4).reverse()), fe.hash256(_.join(d))
            }
        }, taproot: {
            hash: Oe, sign: async function (t, n, e, r = {}) {
                const {sigflag: i = 0} = r, o = dn.schnorr.sign, s = await Oe(n, e, r), a = await o(s, t);
                return 0 === i ? _.raw(a).hex : _.of(...a, i).hex
            }, verify: async function (t, n, e = {}, r = !1) {
                const i = function (t) {
                    return ("string" == typeof t || t instanceof Uint8Array) && (t = L(t)), {...t}
                }(t), {witness: o} = i.input[n];
                if (!Array.isArray(o) || o.length < 1) return le("Invalid witness data: " + String(o), r);
                if (80 === Z(o[o.length - 1])[0] && o.pop(), o.length < 1) return le("Invalid witness data: " + String(o), r);
                const s = new B(Z(o[0])), a = s.read(64), c = i.input[n].prevout, u = Z(c?.scriptPubKey).slice(2);
                let f, h;
                if (1 === s.size && (e.sigflag = s.read(1).num, 0 === e.sigflag)) return le("0x00 is not a valid appended sigflag!", r);
                if (o.length > 1 && (h = Z(o.pop())), o.length > 1 && h instanceof Uint8Array) {
                    const t = N(o.pop()), n = 254 & h[0];
                    f = await Ae(t, n), e.extention = f
                }
                const l = await Oe(i, n, e), d = dn.schnorr.verify;
                return await d(a, l, u) ? !(void 0 !== h && void 0 !== f && !await ve(u, h, f)) || le("Invalid cblock!", r) : le("Invalid signature!", r)
            }
        }
    }, Ie = {
        getTag: be, getLeaf: Ae, getBranch: xe, getRoot: me, getTweak: Ee, getPubkey: async function (t, n = []) {
            return pe(t, n)
        }, getSeckey: async function (t, n = []) {
            return pe(t, n, !0).then((t => t[0]))
        }, getPath: async function t(n, e, r = [e], i = de, o = 0) {
            const s = _.normalize(n), [a, c, u] = await Se(r, e), f = [_.num(i + function (t = 2) {
                if (0 === t || 1 === t) return t;
                if (2 === t || "02" === t) return 0;
                if (3 === t || "03" === t) return 1;
                throw new Error("Invalid parity bit:" + String(t))
            }(o)), _.normalize(n)];
            r.length > 1 && u.forEach((t => f.push(_.hex(t))));
            const h = _.join(f), l = ge(s, await Ee(s, _.hex(a))).slice(1);
            if (!await ve(l, h, e)) {
                if (0 === o) return t(n, e, r, i, 1);
                throw new Error("Path checking failed! Unable to generate path.")
            }
            return h.hex
        }, checkPath: ve, tweakSeckey: ye, tweakPubkey: ge, encodeAddress: function (t, n = "bc") {
            return (t = _.normalize(t)).length > 32 && (t = t.slice(1, 33)), _.raw(t).toBech32(n, 1)
        }, decodeAddress: function (t) {
            return _.bech32(t, 1)
        }
    }, He = {
        encode: function (t, n) {
            const {version: e, input: r, output: i, locktime: o} = t, s = !0 !== n && function (t) {
                for (const n of t) {
                    const {witness: t} = n;
                    if ("string" == typeof t || t instanceof Uint8Array || Array.isArray(t) && t.length > 0) return !0
                }
                return !1
            }(r), a = [k(e)];
            s && a.push(_.hex("0001")), a.push(function (t) {
                const n = [_.readSize(t.length)];
                for (const e of t) {
                    const {txid: t, vout: r, scriptSig: i, sequence: o} = e;
                    n.push(C(t)), n.push(D(r)), n.push(N(i)), n.push(K(o))
                }
                return _.join(n)
            }(r)), a.push(function (t) {
                const n = [_.readSize(t.length)];
                for (const e of t) {
                    const {address: t, value: r, scriptPubKey: i} = e;
                    n.push(j(r)), void 0 !== t ? n.push(_.bech32(t).raw) : n.push(N(i))
                }
                return _.join(n)
            }(i));
            for (const t of r) s && void 0 !== t?.witness && a.push($(t.witness));
            return a.push(V(o)), _.join(a).hex
        }, decode: L
    };
    return t.Script = _e, t.Sig = Be, t.Tap = Ie, t.Tx = He, t
}({});